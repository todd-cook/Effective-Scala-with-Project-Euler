package com.wordtrellis.projecteuler

/**
  * Problem 2
  * Each new term in the Fibonacci sequence is generated by adding
  * the previous two terms. By starting with 1 and 2, the first 10 terms will be:
  * 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
  * Find the sum of all the even-valued terms in the sequence which do not exceed
  * four million.
  *
  * @author : Todd Cook
  *
  */
object problem_2 {

  /**
    * Create a list of Fibonacci integers, up to the given ceiling parameter
    */
  def main(args: Array[String]): Unit = {
    println(make_fibo(89))
    println(make_fibo())
    println(make_fibo().sum)
    println(answer3)
  }

  /**
    *
  This manually defines the first two terms of the Fibonacci sequence, then
    recursively defines an infinite stream of the remaining Fibonacci terms.
    fib is the Fibonacci sequence starting at zero (0, 1, 1, 2, 3, ...).
    fib.tail is the Fibonacci sequence starting at one (1, 1, 2, 3, 5, ...).
    fib.zip(fib.tail) is the two sequences zipped into a sequence of
    pairs ((0, 1), (1, 1), (1, 2), (2, 3), ...).
    We then use map to sum the two parts of each pair (._1 and ._2) and
    complete the recursive definition of the rest of fib,
    after the first two terms (1, 2, 3, 5, ...).
    Thanks to Stream, the terms of the Fibonacci sequence are only evaluated
    as they are needed, so we can represent an infinite stream without
    incurring infinite computation.
    We can verify that we computed the Fibonacci numbers correctly by inspecting
    the first few terms of our Stream with take and print.
    scala> fib.take(15).print
    0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, Stream.empty

    That looks about right. Now lets filter so we only have the even-valued
    Fibonacci terms, use takeWhile to grab the terms below a million, and add
    them up. Since I'm getting tired of foldLeft, let's Pimp my Library and
    add a "sum" method to our Fibonacci sequence (indeed, to any Iterable[Int]).

    res8: Int = 1089154

    adapted from: http://grokcode.com/75/learning-scala-with-project-euler/
    */
  def make_fibo(ceiling: Int = 4000000): List[Int] = {
    lazy val fib: LazyList[Int] =
      LazyList.cons(0, LazyList.cons(1, fib.zip(fib.tail).map(p => p._1 + p._2)))
    import scala.language.implicitConversions
    implicit def iterableWithSum(it: Iterable[Int]): Object {
      def sum: Int
    } = new {
      def sum: Int = it.sum
    }
    var res = fib.filter(_ % 2 == 0).takeWhile(_ <= ceiling)
    res.toList
  }

  def answer3: Int = {
    var total = 0
    var seed  = (1, 2)
    while (seed._2 < 4000000) {
      if (seed._2 % 2 == 0) {
        total = total + seed._2
      }
      seed = fibInc(seed)
    }
    total
  }

  /**
    * Another implementation
    */
  private def fibInc(pair: (Int, Int)): (Int, Int) = {
    (pair._2, pair._1 + pair._2)
  }
}
